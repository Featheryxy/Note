## 重构原则

何为重构:对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本

两顶帽子: 添加新功能和重构。添加新功能时，我不应该修改既有代码，只管添加新功能;重构时我就不能再添加功能，只管调整代码的结构

何时重构:Don Roberts给了我一条准则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。**事不过三，三则重构**

重构使软件更容易理解，增加可读性

如果重写比重构还容易，就别重构了

## 代码坏味道

神秘命名：一个好的命名应该见名知义,**改变函数声明**（124）（用于给函数改名）、**变量改名**（137）、**字段改名**（244）

重复代码：先**移动语句**（223）重组代码顺序再**提炼函数**或**提炼成超类**

过长函数（*）：函数越长，就越难理解。每当以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中

过长参数列表:

- 如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以**查询取代参数**（324）去掉这第二个参数。
- 如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用**保持对象完整**（319）手法，直接传入原来的数据结构。
- 如果有几项参数总是同时出现，可以用**引入参数对象**（140）将其
  合并成一个对象。
- 如果某个参数被用作区分函数行为的标记flag），可以使用**移除标记参数**（314）
- 如果多个函数有同样的几个参数，引入一个类就尤为有意义。你可以使用**函数组合成类**（144）

全局数据：可以从代码库的任何一个角落都可以修改它，难以定位。**封装变量**（132），把全局数据用一个函数包装起来，将这个函数（及其
封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域

可变数据：函数式编程——完全建立在“数据永不改变”的概念基础上：如果要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变

- 封装变量（132）来确保所有数据更新操作都通过很少几个函数来进
  行，使其更容易监控和演进





## 第一组重构

### 提炼函数（Extract Method）

曾用名：提炼函数（Extract Method）

反向重构：内联函数



**将意图与实现分开**

> 如果你需要花时间浏览一段代码才能弄清它到底在干什么，那么就应该将其提炼到一个函数中.并根据它所做的事为其命名

### 内联函数（Inline Method）

曾用名：内联函数（Inline Method）
反向重构：提炼函数

### 提炼变量（Extract Variable）

曾用名：引入解释性变量（Introduce Explaining Variable）

**表达式过于复杂**，如圆的面积`pi*math.power(r,2)`



### 内联变量

曾用名：内联临时变量（Inline Temp）



### 改变函数声明

迁移式做法，将要改变的函数内部提炼成一个新的函数

```
function circum(radius) {
	return 2 * Math.PI * radius;
}
// 迁移式做法，为circum改名，将circum标注为@deprecated
@deprecated
function circum(radius) {
	return circumference(radius);
}
function circumference(radius) {
	return 2 * Math.PI * radius;
}

```

### 封装变量

用函数封装变量，如public修饰的字段

如果变量被广泛使用，考虑运用封装变量（132）将其封装起来



引入参数对象，将对象封装成类



函数组合成类：对同一类数据操作的函数

## 封装

### 封装记录

可变数据：封装成类，通过copy将原来的数据转换成类中的字段，不修改原来的数据

记录型结构

- 需声明合法的字段名字
- 随机使用任何字段名称，如map，list，json散列
  - 小范围使用没有问题
  - 大范围使用由于不知道map里的字段，难以阅读，应该封装成类

### 封装集合

封装集合时人们常常犯一个错误：只对集合变量的访问进行了封装，但依然让取值函数返回集合本身。这使得集合的成员变量可以直接被修改，而封装它的类则全然不知，无法介入。



为避免此种情况，我会在类上提供一些修改集合的方法——通常是“添加”和“移除”方法，但是别人还是可能会直接修改集合中的元素，最好的办法是不要让集合的取值函数返回原始集合

### 以对象取代基本类型

### 以查询取代临时变量

将临时变量抽取到函数里



### 提炼类

### 内联类

### 隐藏委托关系

### 移除中间人

### 替换算法

## 搬移

拆分循环，提炼函数，以管道取代循环

> 拆分循环: 一次循环只做一次事情
>
> 提炼函数：将循环封装成一个函数
>
> 以管道取代循环：使用stream流



## 重新组织数据

循环变量

收集变量

一个变量应该承担一个责任，如果承担多个责任，该变量应该被拆分为多个变量

变量是以输入参数的形式声明又在函数内部被再次赋值，此时也可以考虑拆分变量



尽量把可变数据的作用域限制在最小范围



一种是对象风格，把一系列计算得出的属性包装在数据结构中；

另一种是函数风格，将一个数据结构变换为另一个数据结构。如果源数据会被修改，而你必须负责管理派生数据结构的整个生命周期，那么对象风格显然更好。

但如果源数据不可变，或者派生数据用过即弃，那么两种风格都可行。



可以及时计算（可变数据）的变量应该用函数来代替变量



值对象：不变对象

引用对象：可变对象

## 简化条件逻辑

### 分解条件表达式

提炼条件变量，提炼分支，最后使用三元运算符

### 合并条件表达式

虽然条件变量不同，但是分支的结果相同，可以使用逻辑或进行整合，最后对条件变量提炼函数。

嵌套分支可以使用逻辑与



条件表达式两种风格

- 两个条件分支都属于正常行为

- 只有一套分支是正常行为，另外一条是异常行为

  > 如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的单独检查称为“卫语句”

  

将条件表达式反转以卫语句取代嵌套条件表达式



![image-20220602171243872](重构.assets/image-20220602171243872.png)



## 重构API

1. 查询修改分开

2. 函数参数化

3. 移除标记参数

   > 标记参数（字面量值）：调用者用它来指示被调函数应该执行哪一部分逻辑

4. 保持对象完整性: 传递整个记录

5. 以查询取代参数：如果调用函数时传入了一个值，而这个值由函数自己来获得也是同样容易，这就是重复

6. 以参数取代查询：改变代码的依赖关系——为了让目标函数不再依赖于某个元素

7. 移除设值函数：如果为某个字段提供了设值函数，这就暗示这个字段可以被改变。如果不希望在对象创建之后此字段还有机会被改变，那就不要为它提供设值函数（同时将该字段声明为不可变）

8. 以工厂函数取代构造函数

9. 以命令取代函数：为处理复杂计算，借助命令对象，可以轻松地将
   原本复杂的函数拆解为多个方法，彼此之间通过字段共享状态

10. 以函数取代命令

## 处理继承关系

子类中有相同的行为和属性

1. 函数上移
2. 字段上移
3. 构造函数本体上移

4. 函数下移
5. 字段下移
6. 以子类取代类型码

> 继承：使用多态来处理条件逻辑

7. 移除子类
8. 提炼超类
9. 折叠继承体系：发现一个类与其超类已经没多大差别，把超类和子类合并起来
10. 以委托取代子类：
    - 继承只能用于处理一个方向上的变化，比如说，我可能希望“人”的行为根据“年龄段”不同，并且根据“收入水平”不同。使用继承的话，子类可以是“年轻人”和“老人”，也可以是“富人”和“穷人”，但不能同时采用两种继承方式
    - 继承给类之间引入了非常紧密的关系。在超类上做任何修
      改，都很可能破坏子类
11. 以委托取代超类



对象组合（委托）优于类继承

## 对象

函数：独立于对象

方法：依附于对象

命令对象：将函数封装成自己的对象

