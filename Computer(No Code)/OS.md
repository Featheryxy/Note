操作系统 = 用户界面+资源管理
用户界面

1. 图形化界面
2. 命令行界面
3. 程序用户界面

控制面板（Control Panel）是Windows系统的资源管理员
注销：清除当前登录用户的运行程序和缓存空间，系统还在运行 logoff
关机：shutdown
重启：系统停止运行后，重新启动，系统的配置更新生效 shutdown -r

```cmd
control
systeminfo
regedit.exe
diskpart
```

注册表是Microsoft Windows用于存储系统和应用程序的设置信息的一个重要数据库
《数据文件格式（HKEY_CLASS_ROOT）》
《用户个性化配置（HKEY_CURRENT_USER）》
《软硬件配置信息（HKEY_LOCAL_MACHINE）》
《用户信息（HKEY_USERS）》
《计算机当前设置（HKEY_CURRENT_CONFIG）》

HKEY_CLASS_ROOT：记录Windows操作系统中所有数据文件的格式和关联信息，主要记录不同文件的文件名后缀和与之对应的应用程序。其下子键可分为两类，一类是已经注册的各类文件的扩展名，这类子键前面都有一个“.”；另一类是各类文件类型有关信息
HKEY_CURRENT_USER：我们在系统中设定的个性化配置就在这里，它包含了当前登录用户的配置文件信息。不同的用户登录计算机时，有不同的个性化设置，如自己定义的墙纸、自己的收件箱、自己的安全访问权限等。
HKEY_LOCAL_MACHINE：包含了当前计算机的配置数据，包括所安装的硬件以及软件的设置。这些信息是为用户使用系统服务的，它是整个注册表中最庞大，也是最重要的信息条目。
HKEY_USERS：包括默认用户的信息（Default子键）和所有以前登录用户的信息。
HKEY_CURRENT_CONFIG：存放的是计算机的当前设置信息，如显示器、打印机等外设的设置信息等。它实际上是HKEY_LOCAL_MACHINE中的一部分，其子键与HKEY_LOCAL_MACHINE\Config\0001分支下的数据完全一样

开机自启：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
默认安装路径：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion

在传统的磁盘管理中，可以将一个硬盘分为两大类分区：主分区和扩展分区。硬盘容量等于主分区加扩展分区容量。主分区就是安装操作系统和计算机启动时访问的分区。这样的分区格式化后，可用于安装系统，然后存放文件。一个硬盘的主分区数目是有限制的，例如，一个硬盘至少有一个主分区，最多只能存在4个主分区。

0.0.0.0:22 表示监听服务器上所有ip地址的所有(0.0.0.0表示本地所有ip)

驱动程序起到了让硬件和系统沟通的作用，把硬件的功能告诉计算机系统，并且将计算机系统的指令传达给硬件，让它开始工作





程序在OS上以进程为单位运行。每个程序由一个或者多个进程构成。

进程调用设备是需要驱动，由于不同设备需要不同的驱动，为了减少开发压力，Linux在硬件之上，OS之下提供了一个中间层，设备驱动程序。只有通过设备驱动才能调用设备。另外为了避免多个进程同时调用设备，CPU存在内核模式和用户模式两种模式，只有处于内核模式时才允许访问设备。



另外，使设备驱动程序在内核模式下运行，使进程在用户模式下运行。

把这些在内核模式下运行的OS的核心处理整合在一起的程序就叫作内核。如果进程想要使用设备驱动程序等由内核提供的功能，就需要通过被称为系统调用的特殊处理来向内核发出请求，CPU会先中断，然后切换运行模式，从用户模式切换到内核模式

内核负责管理计算机系统上的CPU和内存等各种资源，然后把这些资源按需分配给在系统上运行的各个进程



![](C:\Users\yexiangyu5\AppData\Roaming\marktext\images\2023-11-27-11-37-04-1701056219243.png)



系统调用种类

1. 进程控制（创建和删除）

2. 内存管理（分配和释放）

3. 进程间通信

4. 网络管理

5. 文件系统操作

6. 文件操作（访问设备）



系统调用只能由汇编语言发起，OS系统提供了系统调用的包装函数



在调用fork() 函数后，就会基于发起调用的进程，创建一个新的进程。发出请求的进程称为父进程，新创建的进程称为子进程

execve() 函数：

1.  读取可执行文件，并读取创建进程的内存映像所需的信息。

2. 用新进程的数据覆盖当前进程的内存。

3. 从最初的命令开始运行新的进程。



在打算新建一个别的进程时，通常采用被称为fork and exec的方式，即由父进程调用fork() 创建子进程，再由子进程调用exec()



使用 _exit() 函数（底层发起exit_group() 系统调用）来结束进程并回收分配给进程的内存

进程调度器

1. 一个CPU同时只运行一个进程

2. 在同时运行多个进程时，每个进程都会获得适当的时长，轮流在CPU上执行处理。

**上下文切换**是指切换正在逻辑CPU上运行的进程。当一个时间片被消耗完后，不管进程正在执行什么代码，都一定会发生上下文切换

进程状态（部分）

1. 运行态

2. 就绪态

3. 睡眠态：进程不准备运行，除非发生某件事情，在此期间不消耗CPU时间
   
   - 等待指定的时间
   
   - 等待用户通过键盘或鼠标等设备进行输入
   
   - 等待HDD或SDD等外部存储器的读写结束
   
   - 等待网络的数据收发结束

4. 僵尸状态



IO时，不需要CPU参与，直接DMA控制

STAT

R: 运行态 或 就绪态

s 或 D：s指可通过接受信号回到运行态，D 指除s以外的状态，主要出现在等待外部存储器的访问时



CPU 空闲状态：在此期间，逻辑CPU会运行一个被称为空闲进程的不执行任何处理的特殊进程。进程在睡眠态时，CPU处在空闲状态



吞吐量：单位时间内的总工作量，越大越好

延迟：各种处理从开始到完成所耗费的时间，越短越好

CPU吞吐量 = 处理完成的进程数量 / 耗费的时间

CPU延迟 = 结束处理的时间 – 开始处理的时间



调度器把CPU时间划分为时长很短的时间片来分配给各个进程，因为如果时间片很长时，如果存在多个进程，则后面的进程延迟会很高

为了能够利用各个逻辑CPU，调度器会运行一个被称为负载均衡或全局调度的功能，将进程按顺序公平的分给每个CPU



运行时间：进程从开始运行到运行结束为止所经过的时间

执行时间：进程实际占用逻辑CPU的时长

当进程数小于逻辑CPU数时，进程只会在一个逻辑CPU中运行，其他逻辑CPU会一直空闲，直到完成。



free

●total字段：系统搭载的物理内存总量。在上面的例子中约为32GB

●free字段：表面上的可用内存量（详情请参考下面的available字段的说明）

●buff/cache字段：缓冲区缓存与页面缓存占用的内存。当系统的可用内存量（free字段的值）减少时，可通过内核将它们释放出来

●available字段：实际的可用内存量。本字段的值为free字段的值加上当内存不足时内核中可释放的内存量。“可释放的内存”指缓冲区缓存与页面缓存中的大部分内存，以及内核中除此以外的用于其他地方的部分内存



内核为进程分配内存的时机大体上分为以下两种。

1. 在创建进程时

2. 在创建完进程后，动态分配内存时。进程向内核发出用于获取内存的系统调用，提出分配内存的请求。内核返回新分配内存的首地址，这种方式会有如下问题
   
   - 内存碎片化
   
   - 访问用于其他用途的内存区域
   
   - 难以执行多任务

通过虚拟内存可以解决上述3个问题

虚拟内存使进程无法直接访问系统上搭载的内存，只能通过虚拟地址间接访问。



进程可以看见的是虚拟地址，系统上搭载的内存的实际地址称为物理地址。此外，可以通过地址访问的范围称为地址空间



通过保存在内核使用的内存中的页表，可以完成从虚拟地址到物理地址的转换。在虚拟内存中，所有内存以页为单位划分并进行管理，地址转换也以页为单位进行。在页表中，一个页面对应的数据条目称为页表项。页表项记录着虚拟地址与物理地址的对应关系。页面大小取决于CPU架构。在x86_64架构中，页面大小为4KB。

当进程访问页面中没有关联物理内存的虚拟地址时，CPU会发生缺页中断，缺页中断可以中止正在执行的命令，并启动内核中的缺页中断机构的处理，内核的缺页中断机构检测到非法访问，向进程发送SIGSEGV信号。接收到该信号的进程通常会被强制结束运行



虚拟地址空间是每个进程独有的。相应地，页表也是每个进程独有的。得益于虚拟内存，进程根本无法访问其他进程的内存。出于实现上的方便，内核的内存区域被映射到了所有进程的虚拟地址空间中。但是，与内核的内存对应的页表项上都注有“内核模式专用”的信息，表明仅允许在CPU运行在内核模式下时访问，因此这部分内存也不可能被运行在用户模式下的进程窥探或损毁
