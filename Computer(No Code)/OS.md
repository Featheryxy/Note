操作系统 = 用户界面+资源管理
用户界面

1. 图形化界面
2. 命令行界面
3. 程序用户界面

控制面板（Control Panel）是Windows系统的资源管理员

用户层面

- 注销：清除当前登录用户的运行程序和缓存空间，系统还在运行 logoff

系统层面

- 关机：shutdown

- 重启：系统停止运行后，重新启动，系统的配置更新生效 shutdown -r

```cmd
control
systeminfo
regedit.exe
diskpart
```

**注册表**是Microsoft Windows用于存储**系统和应用程序的配置信息**的一个重要数据库
《数据文件格式（HKEY_CLASS_ROOT）》
《用户个性化配置（HKEY_CURRENT_USER）》
《软硬件配置信息（HKEY_LOCAL_MACHINE）》
《用户信息（HKEY_USERS）》
《计算机当前设置（HKEY_CURRENT_CONFIG）》

HKEY_CLASS_ROOT：记录Windows操作系统中所有数据文件的格式和关联信息，主要记录不同文件的文件名后缀和与之对应的应用程序。其下子键可分为两类，一类是已经注册的各类文件的扩展名，这类子键前面都有一个“.”；另一类是各类文件类型有关信息
HKEY_CURRENT_USER：我们在系统中设定的个性化配置就在这里，它包含了当前登录用户的配置文件信息。不同的用户登录计算机时，有不同的个性化设置，如自己定义的墙纸、自己的收件箱、自己的安全访问权限等。
HKEY_LOCAL_MACHINE：包含了当前计算机的配置数据，包括所安装的硬件以及软件的设置。这些信息是为用户使用系统服务的，它是整个注册表中最庞大，也是最重要的信息条目。
HKEY_USERS：包括默认用户的信息（Default子键）和所有以前登录用户的信息。
HKEY_CURRENT_CONFIG：存放的是计算机的当前设置信息，如显示器、打印机等外设的设置信息等。它实际上是HKEY_LOCAL_MACHINE中的一部分，其子键与HKEY_LOCAL_MACHINE\Config\0001分支下的数据完全一样

开机自启：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
默认安装路径：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion



在传统的磁盘管理中，可以将一个硬盘分为两大类分区：主分区和扩展分区。硬盘容量等于主分区加扩展分区容量。主分区就是安装操作系统和计算机启动时访问的分区。这样的分区格式化后，可用于安装系统，然后存放文件。一个硬盘的主分区数目是有限制的，例如，一个硬盘至少有一个主分区，最多只能存在4个主分区。



0.0.0.0:22 表示监听服务器上所有ip地址的所有22端口 (0.0.0.0表示本地所有ip)

驱动位于硬件和系统之间，起桥梁作用

> 驱动程序起到了让硬件和系统沟通的作用，把硬件的功能告诉计算机系统，并且将计算机系统的指令传达给硬件，让它开始工作

程序在OS上以进程为单位运行。每个程序由一个或者多个进程构成。

进程调用设备是需要驱动，由于不同设备需要不同的驱动，为了减少开发压力，Linux在硬件之上，OS之下提供了一个中间层，设备驱动程序。只有通过设备驱动才能调用设备。另外为了避免多个进程同时调用设备，CPU存在内核模式和用户模式两种模式，只有处于内核模式时才允许访问设备。

另外，使设备驱动程序在内核模式下运行，使进程在用户模式下运行。

把这些在内核模式下运行的OS的核心处理整合在一起的程序就叫作内核。如果进程想要使用设备驱动程序等由内核提供的功能，就需要通过被称为系统调用的特殊处理来向内核发出请求，CPU会先中断，然后切换运行模式，从用户模式切换到内核模式

内核负责管理计算机系统上的CPU和内存等各种资源，然后把这些资源按需分配给在系统上运行的各个进程

![](C:\Users\yexiangyu5\AppData\Roaming\marktext\images\2023-11-27-11-37-04-1701056219243.png)

系统调用种类

1. 进程控制（创建和删除）

2. 内存管理（分配和释放）

3. 进程间通信

4. 网络管理

5. 文件系统操作

6. 文件操作（访问设备）

系统调用只能由汇编语言发起，OS系统提供了系统调用的包装函数

在调用fork() 函数后，就会基于发起调用的进程，创建一个新的进程。发出请求的进程称为父进程，新创建的进程称为子进程

execve() 函数：

1. 读取可执行文件，并读取创建进程的内存映像所需的信息。

2. 用新进程的数据覆盖当前进程的内存。

3. 从最初的命令开始运行新的进程。

在打算新建一个别的进程时，通常采用被称为fork and exec的方式，即由父进程调用fork() 创建子进程，再由子进程调用exec()

使用 _exit() 函数（底层发起exit_group() 系统调用）来结束进程并回收分配给进程的内存

进程调度器

1. 一个CPU同时只运行一个进程

2. 在同时运行多个进程时，每个进程都会获得适当的时长，轮流在CPU上执行处理。

**上下文切换**是指切换正在逻辑CPU上运行的进程。当一个时间片被消耗完后，不管进程正在执行什么代码，都一定会发生上下文切换

进程状态（部分）

1. 运行态

2. 就绪态

3. 睡眠态：进程不准备运行，除非发生某件事情，在此期间不消耗CPU时间
   
   - 等待指定的时间
   
   - 等待用户通过键盘或鼠标等设备进行输入
   
   - 等待HDD或SDD等外部存储器的读写结束
   
   - 等待网络的数据收发结束

4. 僵尸状态

IO时，不需要CPU参与，直接DMA控制

STAT

R: 运行态 或 就绪态

s 或 D：s指可通过接受信号回到运行态，D 指除s以外的状态，主要出现在等待外部存储器的访问时

CPU 空闲状态：在此期间，逻辑CPU会运行一个被称为空闲进程的不执行任何处理的特殊进程。进程在睡眠态时，CPU处在空闲状态

吞吐量：单位时间内的总工作量，越大越好

延迟：各种处理从开始到完成所耗费的时间，越短越好

CPU吞吐量 = 处理完成的进程数量 / 耗费的时间

CPU延迟 = 结束处理的时间 – 开始处理的时间

调度器把CPU时间划分为时长很短的时间片来分配给各个进程，因为如果时间片很长时，如果存在多个进程，则后面的进程延迟会很高

为了能够利用各个逻辑CPU，调度器会运行一个被称为负载均衡或全局调度的功能，将进程按顺序公平的分给每个CPU

运行时间：进程从开始运行到运行结束为止所经过的时间

执行时间：进程实际占用逻辑CPU的时长

当进程数小于逻辑CPU数时，进程只会在一个逻辑CPU中运行，其他逻辑CPU会一直空闲，直到完成。

free

●total字段：系统搭载的物理内存总量。在上面的例子中约为32GB

●free字段：表面上的可用内存量（详情请参考下面的available字段的说明）

●buff/cache字段：缓冲区缓存与页面缓存占用的内存。当系统的可用内存量（free字段的值）减少时，可通过内核将它们释放出来

●available字段：实际的可用内存量。本字段的值为free字段的值加上当内存不足时内核中可释放的内存量。“可释放的内存”指缓冲区缓存与页面缓存中的大部分内存，以及内核中除此以外的用于其他地方的部分内存

内核为进程分配内存的时机大体上分为以下两种。

1. 在创建进程时

2. 在创建完进程后，动态分配内存时。进程向内核发出用于获取内存的系统调用，提出分配内存的请求。内核返回新分配内存的首地址，这种方式会有如下问题
   
   - 内存碎片化
   
   - 访问用于其他用途的内存区域
   
   - 难以执行多任务

通过虚拟内存可以解决上述3个问题

虚拟内存使进程无法直接访问系统上搭载的内存，只能通过虚拟地址间接访问。

进程可以看见的是虚拟地址，系统上搭载的内存的实际地址称为物理地址。此外，可以通过地址访问的范围称为地址空间

通过保存在内核使用的内存中的页表，可以完成从虚拟地址到物理地址的转换。在虚拟内存中，所有内存以页为单位划分并进行管理，地址转换也以页为单位进行。在页表中，一个页面对应的数据条目称为页表项。页表项记录着虚拟地址与物理地址的对应关系。页面大小取决于CPU架构。在x86_64架构中，页面大小为4KB。

当进程访问页面中没有关联物理内存的虚拟地址时，CPU会发生缺页中断，缺页中断可以中止正在执行的命令，并启动内核中的缺页中断机构的处理，内核的缺页中断机构检测到非法访问，向进程发送SIGSEGV信号。接收到该信号的进程通常会被强制结束运行

虚拟地址空间是每个进程独有的。相应地，页表也是每个进程独有的。得益于虚拟内存，进程根本无法访问其他进程的内存。出于实现上的方便，内核的内存区域被映射到了所有进程的虚拟地址空间中。但是，与内核的内存对应的页表项上都注有“内核模式专用”的信息，表明仅允许在CPU运行在内核模式下时访问，因此这部分内存也不可能被运行在用户模式下的进程窥探或损毁

虚拟内存应用

1. 文件映射

2. 请求分页：在请求分页机制中，对于虚拟地址空间内的各个页面，只有在进程初次访问页面时，才会为这个页面分配物理内存。页面的状态除了前面提到过的“未分配给进程”与“已分配给进程且已分配物理内存”这两种以外，还存在“已分配给进程但尚未分配物理内存”这种状态
   
   ① 进程访问入口点。
   
   ② CPU参照页表，筛选出入口点所属的页面中哪些虚拟地址未关联物理地址。
   
   ③ 在CPU中引发缺页中断。
   
   ④ 内核中的缺页中断机构为步骤①中访问的页面分配物理内存，并更新其页表。
   
   ⑤ 回到用户模式，继续运行进程。
   
   另外，进程并不会感知到自身在运行时曾发生过缺页中断。

3. 写时复制（Copy on Write，CoW）
   
   在发起fork() 系统调用时，并非把父进程的所有内存数据复制给子进程，而是仅复制父进程的页表。虽然在父进程和子进程双方的页表项内都存在表示写入权限的字段，但此时双方的写入权限都将失效（即变得无法进行写入）。在这之后，假如只进行读取操作，那么父进程和子进程双方都能访问共享的物理页面。但是，当其中一方打算更改任意页面的数据时，则将按照下述流程解除共享。
   
   ① 由于没有写入权限，所以在尝试写入时，CPU将引发缺页中断。
   
   ② CPU转换到内核模式，缺页中断机构开始运行。
   
   ③对于被访问的页面，缺页中断机构将复制一份放到别的地方，然后将其分配给尝试写入的进程，并根据请求更新其中的内容。
   
   ④为父进程和子进程双方更新与已解除共享的页面对应的页表项。
   
   ●对于执行写入操作的一方，将其页表项重新连接到新分配的物理页面，并赋予写入权限●对于另一方，也只需对其页表项重新赋予写入权限即可

4. Swap: 将外部存储器的一部分容量暂时当作内存使用。相比对内存的访问速度，对普通的外部存储器的访问速度慢了几个数量级，当系统长期处于内存不足时，访问内存的操作将导致页面不断地被换入和换出，从而导致系统陷入系统抖动（颠簸）状态。
   
   换出与换入这两个处理统称为交换。在Linux中，由于交换是以页为单位进行的，所以也称为分页。同时，换入与换出也分别称为页面调入与页面调出。
   
   swapon --show
   
   free
   
   sar -W 实时查看换入，换出
   
   交换这类需要访问外部存储器的缺页中断称为硬性页缺失
   
   无须访问外部存储器的缺页中断称为软性页缺失

5. 多级页表：随着进程的虚拟内存使用量增加，进程页表使用的物理内存量也会增加，

6. 标准大页

存储层次

内存 ---> 高速缓存 ---> CPU

CPU修改数据后写入高速缓存中，并且标记数据为"脏了"。数据从高速缓存中写入内存后删除标识”"脏了“。当高速缓存空间不足时，需要销毁缓存快，对于脏了的缓存块，数据将在被销毁前被同步到内存中

●时间局部性：在某一时间点被访问过的数据，有很大的可能性在不久的将来会再次被访问，例如循环处理中的代码段

●空间局部性：在某一时间点访问过某个数据后，有很大的可能性会继续访问其附近的其他数据，例如遍历数组元素

进程需要通过下述步骤访问虚拟地址上的特定数据。① 对照物理内存中的页表，把虚拟地址转换为物理地址。② 访问通过步骤①得到的物理地址。

敏锐的人可能已经发现了，这里能发挥高速缓存优势的只有步骤②。这是因为步骤①依然需要访问物理内存，以读取物理内存中的页表。这样一来，特意准备的高速缓存就浪费了。为了解决这一问题，在CPU上存在一个具有与高速缓存同样的访问速度的区域，名为转译后备缓冲区（Translation Lookaside Buffer，TLB），又称为快表或页表缓冲，该区域用于保存虚拟地址与物理地址的转换表

高速缓存是把内存上的数据缓存到高速缓存上，而页面缓存则是将外部存储器上的文件数据缓存到内存上。

高速缓存以缓存块为单位处理数据，而页面缓存则以页为单位处理数据。

当进程读取文件的数据时，内核并不会直接把文件数据复制到进程的内存中，而是先把数据复制到位于内核的内存上的页面缓存区域，然后再把这些数据复制到进程的内存中。第二次读时将直接从页面缓存区域读取文件，不需要访问外部存储器中的数据

文件系统

文件系统以文件为单位管理所有对用户有实际意义的数据块，并为这些数据块添加上名称、位置和大小等辅助信息。它还规范了数据结构，以确定什么文件应该保存到什么位置，内核中的文件系统将依据该规范处理数据

收纳其他文件的特殊文件，这种文件称为目录

文件系统上存在两种数据类型，分别是数据与元数据。

●数据：用户创建的文档、图片、视频和程序等数据内容

●元数据：文件的名称、文件在外部存储器中的位置和文件大小等辅助信息

元数据分为以下几种。

●种类：用于判断文件是保存数据的普通文件，还是目录或其他类型的文件的信息[插图]

●时间信息：包括文件的创建时间、最后一次访问的时间，以及最后一次修改的时间

●权限信息：表明该文件允许哪些用户访问

磁盘配额有以下几种类型。

●用户配额：限制作为文件所有者的用户的可用容量。例如防止某个用户用光/home目录的存储空间。ext4与XFS上可以设置用户配额

●目录配额：限制特定目录的可用容量。例如限制项目成员共用的项目目录的可用容量。ext4与XFS上可以设置目录配额

●子卷配额：限制文件系统内名为子卷的单元的可用容量。大致上与目录配额的使用方式相同。Btrfs上可以设置子卷配额

防止文件系统不一致（移动文件时断电）的技术有很多，常用的是日志（journaling）与写时复制。ext4与XFS利用的是日志，而Btrfs利用的是写时复制

Linux将以文件形式存在的设备分为两种类型，分别为字符设备与块设备。所有设备文件都保存在 /dev目录下。在ls -l的输出中，行首字母为c的是字符设备，为b的是块设备

- 字符设备虽然能执行读写操作，但是无法自行确定读取数据的位置。如终端，鼠标，键盘
  
  > 终端:通过bash等shell程序执行命令的、充满字符的黑白画面或窗口

- 块设备除了能执行普通的读写操作以外，还能进行随机访问，比较具有代表性的块设备是HDD与SSD等外部存储器。块设备可以通过设备文件直接访问，也可以通过在其上构建的文件系统来间接访问。大部分软件采用的是后一种方式

由于各种块设备通用的处理有很多，所以这些处理并不会在设备各自的驱动程序中实现，而是被集成到内核中名为通用块层的组件上来实现

通用块层中的 I/O调度器会将访问块设备的请求积攒一定时间，并在向设备驱动程序发出I/O请求前对这些请求进行如下加工，以提高I/O的性能。

●合并：将访问连续扇区的多个I/O请求合并为一个请求

●排序：按照扇区的序列号对访问不连续的扇区的多个I/O请求进行排序

编写程序时一定要注意以下几点

●尽量将文件中的数据存放在连续的或者相近的区域

●把针对连续区域的访问请求汇集到一次访问请求中

●对于文件，尽量以顺序访问的方式访问尽可能大的数据量
