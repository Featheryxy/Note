### 概述

https://www.omg.org/uml/

UML（Unified Modeling Language，统⼀建模语⾔）

继承: 这些对象共享⼀些相似的特征，并显出⾃⼰的特性；

多态性: 针对相同的消息，不同对象可以具有特殊的表现形式，

关联关系：

- 部分作为整体的成员对象，是整体和部分的关系 part of

  - 组合关系 contains a：部分和整体是共存亡
  - 聚合关系 has a：成员对象的生命周期独立于整体对象

- 在**类A的方法（非构造方法）中使用类B**

  - 依赖关系：A依赖B，在**类A的方法（非构造方法）中使用类B**，类B的生命周期随着类A方法的执行结束而结束

    

### 图形元素

![image-20220924142520639](UML.assets/image-20220924142520639.png)



箭头方向：知道对方的信息时才能指向对方，

- 泛化关系：子类继承父类，扩展了父类，子类指向父类
- 实现关系：实现类实现接口，

线：

- 实线：耦合度强
- 虚线：耦合度低

箭头：依赖关系 关联关系

空心菱形：聚合关系

实心菱形：组合关系，包含整个生命周期

### 类图

![image-20210825154918319](UML.assets/image-20210825154918319.png)

```
[可⻅性]属性名[：类型][=初始值][{属性字符串}]
[可⻅性]操作名[（参数表）][：返回类型][{属性字符串}]
```

可⻅性:

- +: public
- -: private
- #：protected
- ~: package

### 接口

![image-20210825155033688](UML.assets/image-20210825155033688.png)

接⼝（Interface）：是描述类的部分⾏为的⼀组操作，它也是⼀个类提供给另⼀个类的⼀组操作,通常接⼝被描述为抽象操作，也就是只⽤标识（返回值、操作名称、参数表）说明它的⾏为,接⼝只负责定义操作⽽不负责具体的实现。



### 抽象类

![image-20220924142438687](UML.assets/image-20220924142438687.png)

抽象类是包含⼀种或多种抽象⽅法的类，它本⾝不需要构造实例。
定义抽象类后，其他类可以对它进⾏扩充，并且通过实现其中的抽象⽅
法使抽象类具体化。

（1）抽象类可以包含某些实现代码，但接⼝没有任何实现部分；
（2）抽象类可以包含属性，⽽接⼝没有属性；
（3）接⼝可以被结构继承，但抽象类不可以；
（4）抽象类可以有构造函数和析构函数，⽽接⼝没有；
（5）抽象类可以继承其他类和接⼝，⽽接⼝仅仅能继承接⼝；
（6）接⼝⽀持多继承，⽽抽象类仅仅⽀持单继承。



### 类关系

![image-20220924142520639](UML.assets/image-20220924142520639.png)

根据类于类之间 的耦合度从弱到强排列：

依赖关系-->  聚合关系-->组合关系-->泛化关系-->实现关系

依赖关系：在类A的**方法中**（方法参数，局部变量）使用类B

关联关系：在类A的**成员变量**中定义类B

### 关联关系

**箭头和实线**

关联关系可分为依赖关联、聚合关联和组合关联，根据语义区分

- 依赖关系  use a
- 聚合关系 has a
- 组合关系 contains a

Association: 在类A中使用类B来作为一个**成员变量**。

从数量上可分为一对多，多对一，多对多

- 数字：精确的数量
- `*`或者`0..*`：表示0到多个
- `0..1`：表示0或者1个，在Java中经常用一个空引用来实现
- `1..*`：表示1到多个

从关联方向上有单向关联和双向关联

![image-20220924143550698](UML.assets/image-20220924143550698.png)

### 依赖关系

**箭头和虚线， Use a**

![image-20220924143718605](UML.assets/image-20220924143718605.png)

Dependency: A依赖B，在**类A的方法（非构造方法）中使用类B**，类B的生命周期随着类A方法的执行结束而结束

```java
public class B {
  public String field1;   //成员变量

  public void method1() {
    System.println("在类B的方法1中");
  }

  //静态方法
  public static void method2() {                 
    System.out.println("在类B的静态方法2中");
  }
}

//A类依赖于B类，在A类中定义了四个方法，分别演示四种依赖形式。
public class A {
  public void method1() {
    //A依赖于B的第一种表现形式：B为A的局部变量
    B b = new B();
    b.method1();
  }

  public void method2() {
    //A依赖于B的第二种表现形式： 调用B的静态方法
    B.method2();
  }

  public void method3(B b)  {
    //A依赖于B的第三种表现形式：B作为A的方法参数
    String s = b.field1;
  }

  //A依赖于B的第四种表现形式：B作为A的方法的返回值
  public B method4() {
    return new B();
  }
}
```

### 聚合关系 

**空心菱形**

Aggregation：是整体和部分的关系，has-a。

成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。成员对象通常作为构造方法、Setter方法或业务方法的参数注入整体对象中

> 如汽车和引擎
>
> 只能从语义上区分

**空心菱形**

```java
public class Car{
    private Engine e ;
    
    // 构造器注入
    public Car(Engine e){
        this.e = e;
    }
    // set注入
    public void setEngine(Engine engine){
        this.e = engine;
    }
}

public class Engine{
    
}
```

### 组合关系

**实心菱形**

Compostion：是整体和部分的关系, contains a。

整体对象可以控制成员对象的生命周期，一旦整体对象不存在，部分对象也就不存在。通常在整体类的构造方法中直接实例化成员类。

> 如，头和嘴巴的关系

**实心菱形**

```java
public class Head{
    private Mouth mouth;
    public Head(){
        mouth = new Mouth();
    }
}

public class mouth{
    
}
```

### 实现关系

**空心三角和虚线**

Realization: 是接口与实现类之间的关系。空心三角和虚线组成的箭头来表示，从实现类指向接口

### 泛化关系

**空心三角和实线**

Generalization：耦合度最大的一种关系，表示一般于特殊的关系，是父类与子类之间的关系，是一种继承关系，是is-a 的关系。

### Reference

https://zhuanlan.zhihu.com/p/109655171
