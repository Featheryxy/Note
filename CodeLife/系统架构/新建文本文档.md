NoSQL的意思是“不只是SQL”(Not only SQL)
事务中间件又称事务处理管理程序，是当前用得最广泛的中间件之一，主要用于解决分布式环境下的事务一致性问题
常用的分布式事务中间件有GTS、TXC、Seata等
应用部署

1. 应用部署，将应用直接部署在物理机器上，存在进程间资源抢占问题
2. 虚拟机部署，虚拟机技术的本质是硬件虚拟化
3. 容器化部署

**业务**是指商业（或非商业）组织及其运作的活动流程。
**需求分析**是将**非形式化的需求**表述转化为**完整的需求定义**，从而确定软件系统必须做什么的过程。
需求的本质是业务方原始诉求经过产品经理演绎、拆解的产物，一些问题由此而生：需求文档所述与业务方的核心诉求可能不一致；产品设计难免存在遗漏和缺陷。因此，作为工程师，拿到需求后并不是立即投入研发，而是进一步分析需求

需求分析要义：作为工程师，不要急于给出“解决方案”，而应带着问题分析需求，大胆假设，小心求证。例如，需求所述的问题是问题吗？对于问题根因，业务方或产品经理能分析准确吗？产品方案能解决问题吗？产品方案落地成本可接受吗？解决问题的效果可评估吗？

对于MySQL数据库，存储方案的核心是字段设计和索引设计；而对于HBase，核心则是RowKey设计

学习方法
1.场景式学习：就是带着问题去学习

## 需求分析

产品需求：产品需求的本质是业务方的原始诉求经过产品经理演绎、拆解后的产物。主要包含:

1. 产品定义：产品需要做哪些事情

2. 产品设计：如UI

技术需求：性能相关

对于需求，工程师需要明确两个最基本的问题，即做什么(What)和怎么做(How)

学习领域知识：

1. 业务概念

2. 业务背景：业务当前状况，以及对业务发展、变化起重要作用的客观因素

3. 业务问题：业务当前状况与业务预期（或发展规划）之间的差距。

4. 业务诉求：当下或接下来一段时期内业务想到达到的目标（解决业务问题）

5. 业务价值：预期可以产生的收益，即解决业务问题可带来的业务状况的积极转变。

明确业务目标：

明确业务用例



需求层次

1. 用户，业务问题，应对方案

2. 场景，用例，业务模型

3. 详细业务规则

抽象建模

1. 时间

2. 空间：
   
   1. 自顶向下
   
   2. 自底向上

用例就是一组业务相关的成功和失败场景的集合，用来描述参与者如何使用系统来实现其目标

用例图的6个要素

1. 参与者

2. 参与者间的关系

3. 系统边界

4. 用例

5. 参与者与用例的关系

6. .用例之间的关系

7. ![](C:\Users\yexiangyu5\AppData\Roaming\marktext\images\2024-01-19-15-13-10-image.png)



前置条件

主事件流

其他事件流

限制与注释

后置条件



Redis其实是一个缩写，全名为Remote Dictionary Server

数据库的分类

1. 关系型数据库

2. NoSQL数据库：Not Only SQL，泛指非关系型数据库
   
   1. 键值型数据库（Redis）、列式数据库（HBase）、文档型数据库(MongoDB)、搜索型数据库(Elasticsearch)、图数据库等类型

3. NewSQL数据库：提供与NoSQL相同的可扩展性，支持对海量数据的存储管理能力，而且仍基于关系模型，保留了极其成熟的SQL作为查询语言，同时支持ACID事务特性



表设计

表必须定义主键，一般默认为id，整型自增。InnoDB是一种索引组织表，其数据存储的逻辑顺序和索引的顺序是相同的。每张表可以有多个索引，但表的存储顺序只能有一种，InnoDB是按照主键索引的顺序来组织表的，因此不要使用更新频繁的列，如uuid、md5、hash和字符串列作为主键，这些列无法保证数据的顺序增长

外键影响高并发下的性能；其次，在大型项目中，通常会对数据库进行分库分表，如果使用了外键，分库分表将难以实施

慎用触发器和存储过程。触发器和存储过程有很多优点：复用性好，可减少开发量；业务逻辑封装性好，修改方便；安全，不存在SQL注入问题。但它同样存在诸多缺点：业务逻辑依赖数据库，可移植性极差；占用服务器资源多；触发器排错困难等。在互联网领域，用户量、访问量通常非常大，同时业务变更频繁，将业务逻辑放到应用层更为适合。

❑单条记录大小禁止超过8kB。首先，从索引的角度看，InnoDB的页块大小默认为16kB，由于InnoDB采用聚簇索引（即B+树结构）存放数据，每个页块中至少有两行数据，否则就失去了B+树的意义（若每个页中只有一条数据，整个树便成了一条双向链表）。由于每个页块中至少有两行数据，可以得出一行数据的大小限制为8kB。其次，从硬盘扇区大小的角度看，单条记录的大小一般不应超过硬盘的扇区大小。目前硬盘的扇区大小多为4kB（少数硬盘可以到16kB），如果单条记录过大，查找时就需要跨越多个扇区，增加寻道时间，可能导致性能下降。

❑可变长度（例如varchar）一定要按需设计，同时控制单行长度，如果过长会降低数据库Buffer命中率，导致更新、查询性能下降。❑单表一般不超过50个int字段、20个char字段、2个text字段，同时单表列数一般不超过50。❑单表数据量建议控制在500万行以下、2GB内。可以用历史数据归档（常应用于日志数据）、分库分表（常应用于业务数据）等手段来控制数据量大小。500万行并不是MySQL数据库的限制，但数据量过大，对修改表结构、备份、恢复都会有影响。

字段设计

❑建立索引（或后续可能需要建立索引）的字段必须定义为not null，并设置default值。❑若字段需存储小数，尽量使用decimal，而不是float和double，因为float和double在存储时都存在精度损失的问题。如果存储的数据超过decimal的范围，可将数据拆成整数和小数并分开存储。❑避免使用小数存储金额，一般应将其转化为对应货币的最小单位的整数倍来存储。例如人民币19.99元，可转化为1999分存储。

❑避免使用blob、text类型存储大文本、文件、图片，应使用文件系统等方式存储。❑对于字符数据，一般使用varchar类型。如果存储的字符串长度几乎相等，可以使用char定长字符串类型。指定最大长度时，在满足存储需求的前提下应尽量使用更小的值。只有在普通字符串类型长度无法满足时才考虑text类型。

❑varchar长度设计需要根据业务实际需要进行长度控制，一般不超过5000，禁止预留过长空间。例如status使用varchar(128)进行存储就非常不合理。varchar类型在存储层面是根据实际长度进行存储的，但内存分配则是根据指定长度进行的，因此，不合理的长度设计会导致内存的

❑只需要年月日信息时使用date类型，例如出生日期。只需要时间信息时使用time类型，例如列车发车时间。此外，选择时间戳类型时需要注意datetime和timestamp的区别。

❑可以考虑将日期时间分拆为多个数字类型进行存储，或者使用UNIX时间戳。但尽量不要将日期时间数据转化为字符串来存储，因为字符串无法支持数据运算，通常需要依赖应用程序进行转换和处理。

❑如果一个字段同时出现在多个表中，应使用相同的数据类型。例如，员工表中的部门编号(dept_id)字段与部门表中的编号(dept_id)字段应保持类型一致。

索引设计

索引(Index)是一种数据结构，其作用在于提高数据库的查询效率，可以类比字典、火车站的车次表、图书的目录等。索引一般以索引文件的形式存储在磁盘上。如果没有特别指明的话，索引通常就是指由B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认都是使用B+树的索引，因此统称索引。

1.索引的分类

(1)按存储划分

❑聚集索引：表记录的排列顺序和索引的排列顺序一致，因此查询速度快。只要找到第一个索引值记录，其余的连续记录在物理存储层面一样连续存放。为了使表记录和索引的排列顺序一致，在插入记录的时候，会对数据页重新排序，因此聚集索引存在修改慢的缺点。

❑非聚集索引：表记录和索引的排列顺序不一定一致，两种索引都采用B+树的结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表记录的指针。非聚集索引层次多，不会造成数据重排。

(2)按逻辑划分

❑主键索引：一种特殊的唯一索引，不允许有空值。

❑普通索引：最基本的索引，无特殊限制。

❑唯一索引：与普通索引类似，但值必须唯一，可以有空值。使用唯一索引，可在一张表中唯一定位一条记录，通常用于幂等。

❑联合索引：多个字段上建立的索引，提高复合条件查询的速度。



❑主键索引命名格式：pk_字段名。

❑普通索引命名格式：idx_表名_索引字段名。

❑唯一索引命名格式：uk_表名_索引字段名。



3.设计规范❑建立索引时，须仔细评估字段的区分度，应选择区分度高的字段作为索引项。避免在数据区分度低的字段上建立索引，例如性别只有男、女，其筛选能力差，性能与全表扫描类似，建立索引没有实际意义。❑避免在更新频繁的字段上建立索引。更新会导致B+树变更，更新频繁的字段建立索引会大大降低数据库的性能。❑表必须有主键，并且是auto_increment及not null类型的，根据表的实际情况定义无符号的tinyint、smallint、int或bigint。禁止字符串列作为主键。❑索引数量要合理，并非越多越好，单表索引建议控制在5个以内。索引过多会增加CPU、I/O开销，虽然索引可以提高查询效率，但同样也会降低插入和更新的效率，有些情况下甚至会降低查询效率。❑在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。❑合理创建联合索引，避免冗余，如(a,b,c)相当于(a)、(a,b)、(a,b,c)。

❑根据左前缀原则，当建立一个联合索引(a,b,c)，查询条件中只有包含(a)或(a,b)或(a,b,c)的时候才能走索引，(a,c)作为条件的时候只能使用到a列索引，所以这个时候要确保a的返回列不能太多，否则语句设计就不合理；(b,c)则不能走索引。❑建立联合索引必须把区分度高的字段放在前面，比如order_num、user_id等，type、status等筛选性一般的字段不应放在最前面。❑能使用唯一索引的场景应尽量使用，提高查询效率。❑尽量利用覆盖索引来进行查询操作，从而避免回表查询。





❑count(*)：不会将全部字段取出来，而是专门做了优化，不取值，按行累加，不论是否包含null。❑count（主键id）：InnoDB引擎遍历整张表，把每一行的id值都取出来，返回给Server层。Server层拿到id后进行判断，由于主键不可能为空，实际按行累加。❑count(1)：InnoDB引擎遍历整张表，但不取值。Server层对于返回的每一行，会填充一个数字1，而1不为空，实际按行累加。❑count（字段）：如果这个字段定义为not null，从记录中读出自然不可能为null，实际按行累加；如果这个字段定义允许为null，那么执行的时候就需要额外判断，只累加字段非null的行。❑count(distinct col)：计算该列除null之外的不重复数量。如count(distinct col1,col2)，如果其中一列全为null，那么即使另一列有不同的值，也返回为0。❑统计表中记录数时应尽量使用count(*)，而不是count（列名）或count（常量）。count(*)是SQL92定义的标准统计行数的语法，与数据库无关。



sum(col)：当某一列的值全是null时，count(col)的返回结果为0，但sum(col)的返回结果为null，因此使用sum()时需注意NPE（Null Pointer Exception，空指针异常）问题



group by使用相对复杂，通常与count()、order by等联合使用。❑在select后面所有的列中，没有使用聚合函数的列，都必须出现在group by子句中。例如select point,count(id) from t_table group by point，point列未使用聚合函数，则必须出现在group by子句中。❑group by后面的列应尽量建立索引。如果只有一个列建立了索引，则该列应排在最左侧；如果存在多个列建立了联合索引，则这些列应根据联合索引的顺序从最左侧开始排列，否则可能无法命中索引。❑group by与order by联合使用时，order by要放在group by的后面，order by子句中的列必须包含在聚合函数或group by子句中



❑避免隐式类型转化。where条件中必须使用合适的类型，因为MySQL进行隐式类型转化之后，可能会将索引字段类型转化成“=”右边值的类型，导致无法使用索引。例如select uid from t_user where mobile_phone=13055556666，mobile_phone列实际为varchar类型，但在SQL语句中的类型为数字，这样会导致索引失效，正确写法是mobile_phone='13055556666'

❑查询条件慎用函数或表达式。避免在where条件的列（属性）中使用函数或表达式，MySQL无法自动解析这种表达式，从而导致无法使用索引。例如select*from t_user where YEAR(date) <='2022'，即使date建立了索引，也会全表扫描，可优化为值计算：select*from t_user where date <=CURDATE()或者select*from t_user where date<='2022-01-01'。

❑避免负向查询，以及%开头的模糊查询。负向查询条件如not、!=、<>、!<、!>、not in、not like等，会导致全表扫描。对于以“%”开头的模糊查询，如果查询字段和条件字段没有建立索引，也会导致全表扫描

❑避免使用子查询。子查询的结果集无法使用索引，还会产生临时表操作，如果查询数据量大，则会影响效率，消耗过多的CPU及I/O资源，可以将子查询优化为join操作。

避免进行多表join操作。首先，连接表的数量尽量不要超过3张，因为每增加一张表就相当于增加了一次嵌套的循环，严重影响查询的效率；其次，对where条件相关的列创建索引，提升数据过滤效率；最后，对用于连接的字段创建索引，并且该字段在多张表中的类型必须完全一致。

●如果明确知道只有一条结果返回，在语句后加“limit 1”能够提高效率，相当于明确告诉了数据库查询量，让其主动停止游标移动。●获取大量数据时，建议分批次获取数据，每次获取数据少于2000条，结果集应小于1MB。●SQL中使用到or的地方可以改写为用in()，因为or的效率没有in的效率高。●SQL语句中in包含的值不应过多，里面数字的个数建议控制在1000个以内

❑大批量写操作(update、delete、insert)需要分批多次进行。大批量操作可能会造成严重的主从延迟，特别是主从模式下，因为slave需要从master的binlog中读取日志来进行数据同步，而binlog日志为row格式时会产生大量的日志

QPS(Queries Per Second)、TPS(Transactions Per Second)





限流方案

1. 限流粒度
   
   - 单机限流:单机限流是指请求进入某一个服务节点后，由该服务节点判断是否超过限流阈值并采取限流的一种保护措施。单机限流算法主要有令牌桶(Token Bucket)、漏桶(Leaky Bucket)和计数器3种
   
   - 分布式限流：分布式限流的本质是对客户端请求的一种管控，通常是在应用入口层对请求进行访问限制（拦截）

2. 限流手段
   
   - 客户端限流：客户端限流即通过限制客户端发出请求来限制流量，如控制页面点击次数
   
   - 接入层限流：将限流拦截点选在接入层的限流方式，Nginx限流，Nginx主要提供两种限流方式：限制访问频率和限制并发连接数
   
   - 应用层限流：业务代码层面实现精细控制的限流