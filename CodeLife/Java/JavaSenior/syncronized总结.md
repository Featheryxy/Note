并发编程主要有**缓存一致性**问题,

- 计算机硬件模型: 缓存中的数据和内存中的数据不一致
- Java内存模型: **主内存**和**工作内存**中的数据不一致
  - 主内存所有线程都共享
  - 每一个线程有自己的工作内存，不同线程之间不能直接访问对方工作内存中的变量, 只能等一个线程将自己工作内存中的变量同步到主内存中后,其他线程通过访问主内存从而间接实现对其他线程内存变量的访问
  - 工作内存只存储该线程对共享变量的副本. 线程对变量的所有的操作(读，取)都必须在工作内存中完成, 完成后同步到主内存中
- Java内存模型是硬件内存的上一层抽象

工作内存与主内存的同步主要经过如下步骤

```
线程A先lock 主内存中的变量 --> 线程A read 主内存 --> load --> use --> assign --> store --> write -- unlock
1. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值
2. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存
```



由于Java内存模型分为工作内存和主内存,那么带来了三个问题

如果所有线程都只是去读取主内存的数据,那么不会有任何问题. 但是如果有写的操作时, 就会有问题. 假设现在又两个线程A和B

A 去写, B去读, 没有问题

A去读, B 再去写, A读取不到B修改后的值, **可见性**

A, B 同时去写 1. 造成指令重排 **原子性** 2 代码重排 **有序性**

```java
//   指令重排 原子性
一行代码可能对应多条指令,如number++ 他对应如下四条指令, 

getstatic #12
iconst_1
iadd
putstatic #12

如果多个线程执行number++, 可能会有造成如下的排序
getstatic #12
iconst_1

getstatic #12
iconst_1
iadd
putstatic #12

iadd
putstatic #12

// 代码重排 有序性
Java在编译时和运行时会对代码进行优化, 会导致程序最终的执行顺序不一定就是我们编写代码时的顺序
num = 2;
ready = true;
如上述代码, 在执行时可能就变成了如下顺序
ready = true;
num = 2;
```



1. 可见性: 指一个线程对共享变量进行修改，另外的线程并没有立即看到修改后的最新值

   > 先写, 再读. 线程将自己工作内存的数据同步到主内存中有时差, 在这个时差,可能由其他线程来访问主内存

2. 原子性: 当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共享变量，干扰了前一个线程的操作

3. 有序性: Java在编译时和运行时会对代码进行优化，会导致程序最终的执行顺序不一定就是我们编写代码时的顺序

   > 在单线程中没有问题,但是在多线程中,这些代码交替执行可能就有问题



那么如何解决问题上述问题呢?

1. 可见性主要是由于线程在写操作时,工作内存与主内存的不一致性导致的,那么我们只要在写的时候使用lock原子操作同时清空主内存与工作内存之间的数据就能解决改问题
2. 原子性和有序性在单线程中没有问题,所以我们在多线程同步写入主内存的过程中,只要模拟单线程就可解决问题,因此添加锁机制. 多线程并发时, 只有获得锁的那一个线程才能写入主内存. 每次获的锁的那个线程都会先执行lock操作, 然后再去写入主内存
3. 
4. 加synchronized后，依然会发生重排序, 但是在同步代码块中，可以保证只有一个线程执行同步代码中的代码。保证有序性



上述问题可以由synchronized来解决

1. synchronized保证只有一个线程拿到锁，能够进入同步代码块, i.e.:只有一个线程执行同步写入主内存的过程。
2. 执行synchronized时，会对应lock原子操作会刷新工作内存中共享变量的值
3. 加synchronized后，依然会发生重排序，只不过，我们有同步代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性

多个线程抢夺锁来获得执行同步代码块的权力



同步代码块: 由synchronized标注的代码

```java
synchronized (Demo01.class) {
    System.out.println("我是run"); // 该方法内部也有synchronized
    test01();
}
```

那么一块代码由多个synchronized标注时, 假设一个线程已经抢夺到了锁, 他进入内部同步代码块,发现还需要获得锁,如果他已经获得锁后再也无法获得锁,那么这个线程就会在这卡死,这显然不正确, 所以当一个线程或的锁后,他还可以获的锁, 使他还可以进入同步代码块中,这就是synchronized的可重入性.

如果一个线程已经获得了锁,那么其他线程还能获得锁吗?如果能,那该线程就是可被中断的,否则,不可被中断, synchronized标识的代码不可被中断





那么synchronized的特性都有哪些呢

1. 可重入性,线程可以多次获得同一个锁
2. 不可中断性, 一个线程获得锁后，另一个线程想要获得锁，该线程必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断.



synchronized原理



synchronized的锁对象会关联一个锁monitor, 这个monitor不是我们主动创建的,是JVM的线程执行到这个同步代码块,发现锁对象没有monitor就会创建monitor

```
synchronized 编译成字节码后

monitorenter

代码逻辑

monitorexit
```

那么什么是锁呢?锁就是monitor

monitor对象的属性主要有:

```c++
ObjectMonitor() {
    _header = NULL;
    _count = 0;
    _waiters = 0，
    _recursions = 0; // 线程的重入次数
    _object = NULL;  // 存储该monitor的对象
    _owner = NULL;   // 标识拥有该monitor的线程
    _WaitSet = NULL; // 处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock = 0 ;
    _Responsible = NULL;
    _succ = NULL;
    _cxq = NULL;     // 多线程竞争锁时的单向列表
    FreeNext = NULL;
    _EntryList = NULL; // 处于block状态的线程，会被加入到该列表
    _SpinFreq = 0;
    _SpinClock = 0;
    OwnerIsThread = 0;
}
```

1. _owner：初始时为NULL。当有线程占有该monitor时，owner标记为该线程的唯一标识。当线程释放monitor时，owner又恢复为NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线程安全的。
2. \_cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。\_cxq是一个临界资源，JVM通过CAS原子指令来修改\_cxq队列。修改前\_cxq的旧值填入了node的next字段，\_cxq指向新值（新线程）。因此_cxq是一个后进先出的stack（栈）。
3. \_EntryList：_cxq队列中有资格成为候选资源的线程会被移动到该队列中。
4. _WaitSet：因为调用wait方法而被阻塞的线程会被放在该队列中。

_owner: 竞争到锁的线程

_WaitSet：处于等待状态的线程

_EntryList：处于阻塞状态的线程



### synchronized与Lock的区别

1. synchronized是关键字，而Lock是一个接口。
2. synchronized会自动释放锁，而Lock必须手动释放锁。
3. synchronized是不可中断的，Lock可以中断也可以不中断。
4. 通过Lock可以知道线程有没有拿到锁，而synchronized不能。
5. synchronized能锁住方法和代码块，而Lock只能锁住代码块。
6. Lock可以使用读锁提高多线程读效率。
7. synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。