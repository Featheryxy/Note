进程是程序的**动态执行过程**，是**分配和管理资源的基本单位**

线程是进程的子集，一个**可执行的实体**，是**CPU调度和分派的基本单位，基本上不拥有系统资源，共享进程资源**

一个Java应用程序java.exe，其实至少有三个线程**： **main()主线程**， **gc()垃圾回收线程**，**异常处理线程

并行与并发

- 并行（parallel）：多个CPU同时执行多个任务。
- 并发（concurrent）：一个CPU同时应对（dealing with）多件事情的能力，即线程轮流使用同一个CPU  

同步与异步

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步



Runnable：任务

Callable：任务

FutureTask：任务 有返回值

> FutureTask<V> implements RunnableFuture<V>
>
> FutureTask(Callable<V> callable)
>
> 

Thread：线程

> Thread(Runnable target)
>

Runnable与Thread

`public class Thread implements Runnable`

优先选择实现Runnable接口的方式

1. 避免java单继承带来的局限性(interface Runnable,  class Thread)

2. 把线程和任务解耦

   

windows中tasklist 查看进程

linux中 ps -ef查看进程

jps 命令查看所有 Java **进程**
jstack <PID> 查看某个 Java 进程（PID）的所有**线程**状态
jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）







线程状态：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED

守护线程：当其他非守护线程结束时，即使其任务没有完成，也会结束

不想向外暴露的成员变量设置成final，防止子类覆盖父类，造成线程不安全



sleep() 和 wait()

相同点：一旦执行方法，都可以使得当前的**线程进入阻塞**状态。

不同点：

- 两个方法**声明的位置**不同：**Thread类中声明sleep()** , **Object类中声明wait()**
- 调用的要求不同：sleep()可以在**任何场景**下调用。 wait()必须使用在**同步代码块**或**同步方法**中
- sleep()不会释放锁**，**wait()会释放锁。
- wait(), notify(), notifyAll()





公平锁：排队，先进先出

