# 执行顺序

当前类的静态代码块 —> main() —> 静态代码块 —> 代码块 —> 构造函数

静态块：用static申明，JVM加载类时执行，仅执行一次

构造块：类中直接用{}定义，每一次创建对象时执行

静态块按照声明顺序执行

```java

public class StaticDemo {
	StaticDemo(){
		System.out.println("StaticDemo构造函数");
	}

	static void StaticDemo(){
		System.out.println("StaticDemo静态方法");
	}

	static{
		System.out.println("StaticDemo静态代码块");
	}

	public static void main(String[] args) {
		new A();
		System.out.println("...");
		A.staticA();
		// StaticDemo静态代码块
		//A静态代码块1
		//A静态代码块2
		//A 代码块
		//A 的构造函数
		//...
		//static A
		//static A2
	}
}

class A{
	static {
		System.out.println("A静态代码块1");
	}

	static {
		System.out.println("A静态代码块2");
	}

	A(){
		System.out.println("A 的构造函数");
	}

	{
		System.out.println("A 代码块");
	}

	public static void staticA2(){
		System.out.println("static A2");
	}

	public static void staticA(){
		System.out.println("static A");
		staticA2();
	}
}
```

子类继承父类时，编译（执行当前类及父类的静态代码块），再完成父类的初始化（代码块，构造函数）

```java
publicclassA {
publicA(){
        System.out.println("A的构造函数");
    }

    {
        System.out.println("A的代码块");
    }

static {
        System.out.println("A的静态代码块");
    }
}

classBextendsA{
publicB(){
        System.out.println("B的构造函数");
    }

    {
        System.out.println("B的代码块");
    }

static {
        System.out.println("B的静态代码块");
    }

publicstaticvoidmain(String[] args) {
new B();
        /*
        A的静态代码块
        B的静态代码块
        A的代码块
        A的构造函数
        B的代码块
        B的构造函数
         */
    }
}
```

```java
packagetest;

public classConstructeTest {
public staticConstructeTestt1=newConstructeTest();

    {
        System.out.println("block A");
    }

static
{
        System.out.println("block B");
    }

public static voidmain(String[] args) {
        ConstructeTest t2 =newConstructeTest();
//        block A
//        block B
//        block A

//静态块：用static申明，JVM加载类时执行，仅执行一次
//构造块：类中直接用{}定义，每一次创建对象时执行
//执行顺序优先级：静态块>main()>构造块>构造方法  静态块按照申明顺序执行。
}
}

```