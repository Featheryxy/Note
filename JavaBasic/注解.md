# Annontation

## 1 概述  

- 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解)  

- Annotation 其实就是代码里的特殊标记, 这些标记可以在**编译, 类加载, 运行时被读取**, **并执行相应的处理**。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。 代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。  
- Annotation 可以像修饰符一样被使用, 可用于**修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明**, 这些信息被**保存在 Annotation的 “name=value” 对中**。  
- 框架 = 注解 + 反射 + 设计模式。  

## 2 常见的Annotation示例  

### 2.1 文档相关  

@author 标明开发该类模块的作者， 多个作者之间使用,分割
@version 标明该类模块的版本
@see 参考转向， 也就是相关主题
@since 从哪个版本开始增加的
@param 对方法中某参数的说明， 如果没有参数就不能写
@return 对方法返回值的说明， 如果方法的返回值类型是void就不能写
@exception 对方法可能抛出的异常进行说明 ， 如果方法没有用throws显式抛出的异常就不能写
其中
	@param @return 和 @exception 这三个标记都是只用于方法的。
	@param的格式要求： @param 形参名 形参类型 形参说明
	@return 的格式要求： @return 返回值类型 返回值说明
	@exception的格式要求： @exception 异常类型 异常说明
	@param和@exception可以并列多个  

### 2.2 三个基本注解

@Override: 限定**重写父类方法**, 该注解只能用于方法
@Deprecated: 用于表示**所修饰的元素(类, 方法等)已过时**。通常是因为所修饰的结构危险或存在更好的选择
@SuppressWarnings: **抑制编译器**警告  

## 3 自定义 Annotation  

如何自定义注解：参照@SuppressWarnings定义

1. 注解声明为：@interface, 自动继承了java.lang.annotation.Annotation接口  
2. 内部定义成员，通常使用value表示
3. 可以指定成员的默认值，使用default定义
4. 如果自定义注解**没有成员**，表明是一个**标识作用**。

```java
@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE, ElementType.MODULE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value(); // 成员，非方法
}
```

ps: 
   如果注解有成员，在使用注解时，需要指明成员的值。
   自定义注解必须配上注解的信息处理流程(使用反射)才有意义。
   自定义注解通过都会指明两个元注解：Retention、Target

```java
@Inherited
@Repeatable(MyAnnotations.class)
@Retention(RetentionPolicy.RUNTIME)
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE})
public @interface MyAnnotation {

    String value() default "hello";
}
```

## 4 元注解

4种元注解
元注解：对现有的注解进行解释说明的注解
**@Retention**：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME  只有声明为RUNTIME生命周期的注解，才能通过反射获取。

- RetentionPolicy.SOURCE:在源文件中有效（即源文件保留） ， 编译器直接丢弃这种策略的注释
- RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM不会保留注解。 这是默认值
- RetentionPolicy.RUNTIME:在运行时有效（即运行时保留） ， 当运行 Java 程序时, JVM 会保留注释。程序可以**通过反射获取该注释**。  

**@Target**: 用于指定被修饰的 Annotation 能用于修饰哪些程序元素

![](注解.assets/Target)

*******出现的频率较低*******
**@Documented**: 表示所修饰的注解在被javadoc解析时，保留下来。

- 定义为Documented的注解必须设置Retention值为RUNTIME  

**@Inherited**: 被它修饰的 Annotation 将具有继承性。

- 如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解  

## 5 JDK8中注解的新特性  

### 5.1 可重复注解

1. 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class
2. MyAnnotation的Target和Retention等元注解与MyAnnotations相同。



MyAnnotation

```java
@Inherited
@Repeatable(MyAnnotations.class)
@Retention(RetentionPolicy.RUNTIME)
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE})
public @interface MyAnnotation {

    String value() default "hello";
}
```

MyAnnotations

```java
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
public @interface MyAnnotations {

    MyAnnotation[] value();
}
```

```java
//jdk 8之前的写法：
//@MyAnnotations({@MyAnnotation(value="hi"),@MyAnnotation(value="hi")})
@MyAnnotation(value="hi")
@MyAnnotation(value="abc")
class Person{
    private String name;
    private int age;

    public Person() {
    }
    @MyAnnotation
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    @MyAnnotation
    public void walk(){
        System.out.println("人走路");
    }
    public void eat(){
        System.out.println("人吃饭");
    }
}
```

### 5.2 类型注解

- ElementType.TYPE_PARAMETER  表示该注解能写在**类型变量的声明语句**中（如：泛型声明）。
- ElementType.TYPE_USE  表示该注解**能写在使用类型的任何语句**中。

```java
@Inherited
@Repeatable(MyAnnotations.class)
@Retention(RetentionPolicy.RUNTIME)
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER, TYPE_USE})
public @interface MyAnnotation {

    String value() default "hello";
}
```

```java
//           TYPE_PARAMETER,
class Generic<@MyAnnotation T>{

    public void show() throws @MyAnnotation RuntimeException{ // TYPE_USE

        ArrayList<@MyAnnotation String> list = new ArrayList<>(); // TYPE_USE

        int num = (@MyAnnotation int) 10L; // TYPE_USE
    }

}
```

