面向对象分层架构（Clean Object-oriented and Layered Architecture，COLA ）

### 命名

变量命名: 名词， 体现业务语义，尽量减少对数据的判断

函数命名：

类名：实体类（Customer）和辅助类（CustomerService）

包名：类的更高层次抽象，如有一组类Apple、Pear、Orange， 其包名可以为fruit

模块名：一个模块中包含了多个包, <groupId, artifactId>

常量：PAGE_SIZE

限定词后置：revenueAverage（平均收入），customerNum表示的是当前客户的序号，最好使用customerId来替代

新增：create

添加：add

删除：remove

修改：update

查询(单个结果)：get

查询（多个结果）：list

分页查询：page

统计：count

安装 onlinesearch 命名工具



业务系统中应该设定两个异常 1. BizException 业务异常 2. SysException 系统异常，且都应该是Unchecked Exception

### 函数

封装判断：使用函数将判断封装，函数名体现业务语义

函数参数：越少越好，参数应该小等于2个，超过2个应该使用对象封装.也有例外。

函数应该遵循职责单一的原则，一个方法只做一件事情.

```java
public void pay(List<Employee> employees){
    for (Employee e: employees){
        if(e.isPayDay()){
            Money pay = e.calculatePay();
            e.deliverPay(pay);
        }
    }
}

// 遍历所有雇员，检查是否该发工资，然后支付薪水拆分

public void pay(List<Employee> employees){
    for (Employee e: employees){
    	payIfNecessary(e);
    }
}

private void payIfNecessary(Employee e) {
    if(e.isPayDay()){
    	calculateAndDeliverPay(e);
    }
}

private void calculateAndDeliverPay(Employee e) {
    Money pay = e.calculatePay();
    e.deliverPay(pay);
}
```

SLAP：抽象层次一致性（Single Level of Abstration Principle，SLAP）。组合函数要求将一个大函数拆成多个子函数的组合，而SLAP要求函数体中的内容必须在同一个抽象层次上。如果不在同一个层次，应该再次封装函数

函数编程：在函数式编程中，函数不仅可以调用函数，也可以作为参数被其他函数调用

- 减少冗余代码，让代码更简洁、可读性更好。
- 函数是“无副作用”的，即没有对共享的可变数据操作，可以利用多核并行处理，而不用担心线程安全问题

按照代码冗余程度排序，经典类大于匿名类，匿名类大于 Lamda（匿名函数），Lamda大于方法引用



### 设计原则

SOLID

Single Responsibility Principle（SRP）：单一职责原则。

> 一个方法只做一件事情. 
>
> 是否只有一个被修改的原因

Open Close Principle（OCP）：开闭原则。

> 对扩展开放，对修改关闭

Liskov Substitution Principle（LSP）：里氏替换原则。

> 程序中的父类型都应该可以正确地被子类型替换

Interface Segregation Principle（ISP）：接口隔离原则。

> 多个特定客户端接口要好于一个宽泛用途的接口。

Dependency Inversion Principle（DIP）：依赖倒置原则

> 模块之间交互应该依赖抽象，而非实现。



DRY是Don’t Repeat Yourself, 避免重复代码, 系统的每一个功能都应该有唯一的实现

YAGNI（You Ain’t Gonna Need It）的意思是“你不会需要它”, 除
了核心的功能之外，其他的功能一概不要提前设计

> DRY原则和
> YAGNI原则是不兼容的。前者追求“抽象化”，要求找到通用的解决方
> 法；后者追求“快和省”，意味着不要把精力放在抽象化上面，因为很可
> 能“你不会需要它”。因此，就有了Rule of Three原则

Rule of Three也被称为“三次原则”，是指当某个功能第三次出现时，就有必要进行“抽象化”了

KISS（Keep It Simple and Stupid）把事情变复杂很简单，把事情变简单很
复杂

### 设计模式

（1）单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点，以便外部获取该实例，其拓展是有限多例模式。
（2）原型（Prototype）模式：将一个对象作为原型，通过对其进行复制操作而复制出多个和原型类似的新实例。
（3）工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
（4）抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
（5）建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同的需要分别创建它们，最后构建成该复杂对象。
（6）代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问，即客户端通过代理间接地访问该对象，从而限制、增强或修改
该对象的一些特性。
（7）适配器（Adapter）模式：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
（8）桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现
这两个可变维度的耦合度。
（9）装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
（10）外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
（11）享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
（12）组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
（13）模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使子类可以在不改变该算法结构的情况下，重定义该算法的某些特定步骤。
（14）策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客
户。
（15）命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
（16）职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式可以去除对象之间的耦合。
（17）状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
（18）观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
（19）中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
（20）迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
（21）访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象
访问。
（22）备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
（23）解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

拦截器模式（Interceptor Pattern），是指提供一种通用的扩展机制，可以在业务操作前后提供一些切面的（Cross-Cutting）的操作。这
些切面操作通常是和业务无关的，比如日志记录、性能统计、安全控制、事务处理、异常处理和编码转换等。

插件（plug-in）模式扩展方式和普通的对象扩展方式的不同之处在于，普通的扩展发生在软件内部，插件式扩展发生在软件外部。

### DDD

领域驱动设计（Domain Driven Design，DDD）



抽象层次：层次越往上，抽象程度越高，它所包含的东西就越多，其含义越宽泛，忽略的细节也越多。

How: 抽象的过程就是合并同类项、归并分类和寻找共性的过
程。
