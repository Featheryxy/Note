并发编程主要有缓存一致性问题,

- 计算机硬件模型: 缓存中的数据和内存中的数据不一致
- Java内存模型: 主内存和工作内存中的数据不一致
  - 主内存所有线程都共享
  - 每一个线程有自己的工作内存，不同线程之间不能直接访问对方工作内存中的变量, 只能等一个线程将自己工作内存中的变量同步到主内存中后,其他线程通过访问主内存从而间接实现对其他线程内存变量的访问
  - 工作内存只存储该线程对共享变量的副本. 线程对变量的所有的操作(读，取)都必须在工作内存中完成, 完成后同步到主内存中
- Java内存模型是硬件内存的上一层抽象

工作内存与主内存的同步主要经过如下步骤

```
lock --> read --> load --> use --> assign --> store --> write -- unlock
1. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值
2. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存
```



由于Java内存模型分为工作内存和主内存,那么带来了三个问题

如果所有线程都只是去读取主内存的数据,那么不会有任何问题. 但是如果有写的操作时, 就会有问题. 假设现在又两个线程A和B

A 去写, B去读, 没有问题

A去读, B 再去写, A读取不到B修改后的值, **可见性**

A, B 同时去写 1. 造成指令重排 **原子性** 2 代码重排 **有序性**

```java
//   指令重排 原子性
一行代码可能对应多条指令,如number++ 他对应如下四条指令, 

getstatic #12
iconst_1
iadd
putstatic #12

如果多个线程执行number++, 可能会有造成如下的排序
getstatic #12
iconst_1

getstatic #12
iconst_1
iadd
putstatic #12

iadd
putstatic #12

// 代码重排 有序性
Java在编译时和运行时会对代码进行优化, 会导致程序最终的执行顺序不一定就是我们编写代码时的顺序
num = 2;
ready = true;
如上述代码, 在执行时可能就变成了如下顺序
ready = true;
num = 2;
```



1. 可见性: 指一个线程对共享变量进行修改，另外的线程并没有立即看到修改后的最新值

   > 先写, 再读. 线程将自己工作内存的数据同步到主内存中有时差, 在这个时差,可能由其他线程来访问主内存

2. 原子性: 当一个线程对共享变量操作到一半时，另外的线程也有可能来操作共享变量，干扰了前一个线程的操作

3. 有序性: Java在编译时和运行时会对代码进行优化，会导致程序最终的执行顺序不一定就是我们编写代码时的顺序

   > 在单线程中没有问题,但是在多线程中,这些代码交替执行可能就有问题



那么如何解决问题上述问题呢?

1. 可见性主要是由于线程在写操作时,工作内存与主内存的不一致性导致的,那么我们只要在写的时候使用lock原子操作同时清空主内存与工作内存之间的数据就能解决改问题
2. 原子性和有序性在单线程中没有问题,所以我们在多线程同步写入主内存的过程中,只要模拟单线程就可解决问题,因此添加锁机制. 多线程并发时, 只有获得锁的那一个线程才能写入主内存. 每次获的锁的那个线程都会先执行lock操作, 然后再去写入主内存
3. 
4. 加synchronized后，依然会发生重排序, 但是在同步代码块中，可以保证只有一个线程执行同步代码中的代码。保证有序性



上述问题可以由synchronized来解决

1. synchronized保证只有一个线程拿到锁，能够进入同步代码块, i.e.:只有一个线程执行同步写入主内存的过程。
2. 执行synchronized时，会对应lock原子操作会刷新工作内存中共享变量的值
3. 加synchronized后，依然会发生重排序，只不过，我们有同步代码块，可以保证只有一个线程执行同步代码中的代码。保证有序性

多个线程抢夺锁来获得执行同步代码块的权力

synchronized的特性