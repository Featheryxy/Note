## 纵向

### 字符组

```
a         普通字符 匹配a
[abc]     字符集合 匹配a 或 匹配b 或 匹配c
[^abc]    字符集合取反
[a-zA-Z0-9]
******************************
\d      [0-9]        digit 一位数字
\D      [^0-9]       非数字
\w      [a-zA-Z0-9]  数字，字母，下划线  word
\W      [^a-zA-Z0-9]
\s      [\t\v\n\r\f]  space 空白字符
\S      [^\t\v\n\r\f]   非空白字符
.                       通配符

```







## 横向

### 量词

```markdown
x{m, n}   x匹配m到n次
x{m,}     x匹配至少m次
x{m}      x匹配m次


x*        x匹配任意次，包含0次
x+        x匹配至少一次     x{1，}
x?        x匹配零次或一次   x{0} 或 x{1}
```



```java
package reg;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Demo3 {
    public static void main(String[] args) {
        // group：将一个正则表达式分成多个group, group(0)为匹配到的字符
        // groupCount()不包含group(0)，
        String regex = "(\\d{3})(\\d{3})(\\d{4})";

        // 通过Pattern类的静态方法static Pattern.compile() 编译正则表达式，
        // 利用Pattern的*matcher()*方法生产Matcher对象。根据Matcher对象提供的API完成相应的操作
        Pattern p = Pattern.compile(regex);
        String source = "1234567890, 12345,  and  9876543210";

        Matcher m = p.matcher(source);

        while (m.find()) {
            int i = m.groupCount();
            StringBuilder stringBuilder = new StringBuilder();
            for (int j = 0; j < i+1; j++) {
                stringBuilder.append(j).append(": ").append(m.group(j)).append("\t");
            }
            System.out.println(stringBuilder);
        }
        // 0: 1234567890	1: 123	2: 456	3: 7890	
		// 0: 9876543210	1: 987	2: 654	3: 3210	

    }
}

```

